```markdown
# CHAPTER 4 â€” DEVELOPER TOOLCHAIN & GIT (Industrial Training Notes)

## 4.1 Command Line Interface (CLI) Basics
**Industrial Context:** In professional backend development, 95% of server administration, deployment, and development workflows happen via CLI. GUI tools are secondary. Mastery of CLI is non-negotiable for production environments, container management, CI/CD pipelines, and cloud infrastructure.

### Filesystem Navigation & Core Commands
**Philosophy:** The CLI treats everything as a file or process. Paths are absolute (from root `/`) or relative (from current directory `.`).

#### Navigation Commands
```bash
# Print Working Directory - shows your current location in filesystem
pwd
# Output: /home/username/projects

# List directory contents with flags for professional use
ls -la  # -l: long format (permissions, size, date), -a: show hidden files (starting with .)
# Output shows: drwxr-xr-x  user group  size date_time filename
# d = directory, rwx = owner permissions, r-x = group, r-x = others

# Change Directory with absolute and relative paths
cd /var/log                 # Absolute path from root
cd ../../                   # Go up two directories
cd ~/Documents              # ~ expands to home directory
cd -                        # Switch to previous directory (like "back")
```

**Real-World Example:** Debugging production issues by navigating to application logs:
```bash
cd /var/log/nginx
ls -lt | head -5  # List 5 most recent files sorted by time
```

#### File Operations
**Critical Warning:** `rm` is PERMANENT in Linux. No recycle bin. Use with extreme caution.

```bash
# Create nested directories in one command (common in project setup)
mkdir -p project/{src,test,docs,config}  # Creates project with subdirectories

# Copy files with preservation of metadata
cp -rp source_dir/ destination_dir/  # -r: recursive, -p: preserve permissions/timestamps

# Move/rename files (atomic operation)
mv old_filename.txt new_filename.txt  # Renaming
mv file.txt /target/directory/        # Moving

# Remove files/directories (DANGEROUS COMMANDS)
rm file.txt                          # Remove file
rm -rf directory/                    # -r: recursive, -f: force (no confirmation)
```

**Industrial Best Practices:**
1. **NEVER** run `rm -rf /` or `rm -rf *` without absolute certainty
2. Use `-i` flag for interactive deletion when learning: `rm -i file.txt`
3. Always double-check paths before destructive operations
4. Implement aliases for safety: `alias rm='rm -i'` in your `.bashrc`

#### Permission System (Octal Notation)
**Why It Matters:** Server security breaches often happen through incorrect file permissions.

```bash
# Understanding permission string: drwxr-xr--
# Position: 0   123   456   789
# 0: file type (- file, d directory, l link)
# 1-3: owner permissions (rwx)
# 4-6: group permissions (r-x)
# 7-9: others permissions (r--)

# Change permissions with chmod
chmod 755 script.sh    # Owner: rwx, Group: r-x, Others: r-x (common for executables)
chmod 644 config.json  # Owner: rw-, Group: r--, Others: r-- (common for config files)

# Change ownership (usually requires sudo)
sudo chown www-data:www-data /var/www/html  # User: www-data, Group: www-data
```

#### Process Management
**Production Scenario:** Monitoring and managing backend services.

```bash
# View running processes
ps aux | grep node      # Find all Node.js processes
top                    # Interactive process viewer (like Task Manager)

# Kill processes (graceful vs forced)
kill 1234              # SIGTERM (graceful shutdown - process can clean up)
kill -9 1234           # SIGKILL (immediate force kill - last resort)

# Run process in background and manage jobs
npm start &            # & runs process in background
jobs                   # List background jobs
fg %1                  # Bring job 1 to foreground
ctrl + z               # Suspend current process
bg                     # Resume suspended process in background
```

## 4.2 Version Control with Git & GitHub
**Industrial Reality:** Git is the industry standard. Every professional developer must understand branching strategies, conflict resolution, and collaborative workflows. Companies lose millions from poorly managed version control.

### Git Fundamentals & Repository Lifecycle

#### Initialization & Basic Workflow
```bash
# Initialize repository (creates .git directory with version database)
git init
# Output: Initialized empty Git repository in /path/.git/

# Configure identity (CRITICAL for team attribution)
git config --global user.name "John Doe"
git config --global user.email "john@company.com"
git config --global core.editor "code --wait"  # VS Code as commit editor

# Check repository status
git status
# Shows: untracked files, staged changes, branch information

# The Three States of Git:
# 1. Working Directory: Live files you're editing
# 2. Staging Area (Index): Files marked for next commit
# 3. Repository (HEAD): Committed snapshots
```

#### Staging and Committing
```bash
# Add files to staging area (multiple patterns)
git add file.txt              # Single file
git add *.js                  # All JavaScript files
git add src/                  # Entire directory
git add .                     # ALL changes (use cautiously)

# Remove files from staging area (undo git add)
git reset HEAD file.txt       # Unstage file while keeping changes
git checkout -- file.txt      # DISCARD changes in working directory (irreversible!)

# Create commit with descriptive message
git commit -m "Implement user authentication middleware

- Add JWT token validation
- Implement password hashing with bcrypt
- Create middleware for protected routes"

# Best Practice: Use conventional commit format
git commit -m "feat(auth): implement JWT token validation

- Add token generation endpoint
- Implement middleware for route protection
- Add token refresh mechanism

Closes #123"  # Reference to issue tracker
```

**Professional Commit Guidelines:**
1. Commit early, commit often (small, logical changes)
2. Write meaningful commit messages in imperative mood
3. Include context: what changed and WHY
4. Reference issue/ticket numbers
5. Never commit sensitive data (API keys, passwords)

### Branching Strategy & Merge Workflows
**Industrial Standard:** Git Flow or GitHub Flow are common. Feature branches are mandatory.

#### Branch Operations
```bash
# Create and switch to new branch
git branch feature/auth        # Create branch
git checkout feature/auth      # Switch to branch
# OR combined:
git checkout -b feature/auth   # Create and switch

# List all branches
git branch                    # Local branches
git branch -a                 # All branches (including remote)
git branch -r                 # Remote branches only

# Delete branches (safely)
git branch -d feature/old     # Delete if merged (safe)
git branch -D feature/abandoned  # Force delete (even if not merged)

# Compare branches
git diff main..feature/auth   # Show differences between branches
git log main..feature/auth    # Show commits in feature not in main
```

#### Merging Strategies
**Three Types of Merges:**
1. **Fast-Forward Merge:** Linear history (when no divergence)
2. **Three-Way Merge:** Creates merge commit (default)
3. **Squash Merge:** Condenses all feature commits into one

```bash
# Switch to target branch and merge
git checkout main
git merge feature/auth

# Handle merge conflicts (REAL-WORLD SCENARIO)
<<<<<<< HEAD
// Current branch code (main)
const port = 3000;
=======
// Incoming branch code (feature/auth)
const port = process.env.PORT || 3000;
>>>>>>> feature/auth

# After resolving conflicts:
git add server.js
git commit -m "Merge feature/auth, resolve port configuration"
```

**Rebasing vs Merging:**
```bash
# Rebasing: Clean linear history (DANGER: rewrites history)
git checkout feature/auth
git rebase main              # Replay feature commits on top of main

# Golden Rule: Never rebase public/shared branches
# Only rebase local branches before merging
```

### Remote Collaboration with GitHub/GitLab

#### Connecting to Remote Repositories
```bash
# Add remote repository (origin is conventional name)
git remote add origin https://github.com/username/repo.git
git remote -v                 # Verify remotes

# Push to remote with upstream tracking
git push -u origin main      # -u sets upstream for future pushes
# Later just: git push

# Pull changes (fetch + merge)
git pull origin main
# Equivalent to:
git fetch origin             # Download changes
git merge origin/main        # Merge into current branch
```

**Production Pull Strategies:**
```bash
# Safe pull with rebase (avoid merge commits in main)
git pull --rebase origin main

# Fetch and inspect before merging
git fetch origin
git log origin/main --oneline  # See what's coming
git diff origin/main          # Review changes
git merge origin/main         # Merge after review
```

#### Pull Request Workflow (Industry Standard)
**Process:**
1. Create feature branch from `main`
2. Develop and commit locally
3. Push to remote: `git push origin feature/auth`
4. Open Pull Request on GitHub
5. Code review, automated tests, CI/CD checks
6. Address review comments (commit/push updates)
7. Approve and merge (squash or regular)

```bash
# Real workflow example:
git checkout -b fix/database-connection
# ... make changes ...
git add .
git commit -m "fix(db): handle connection timeout gracefully"
git push origin fix/database-connection

# After PR approval and merge, clean up:
git checkout main
git pull origin main
git branch -d fix/database-connection
```

### Advanced Git Operations for Production

#### Stashing Work-in-Progress
```bash
# Save uncommitted changes temporarily
git stash push -m "WIP: auth middleware"
# Now you have clean working directory

# List stashes
git stash list

# Apply stash (keeps in stash list)
git stash apply stash@{0}

# Pop stash (apply and remove)
git stash pop

# Create branch from stash
git stash branch new-feature stash@{0}
```

#### Undoing Changes (Safety Levels)
```bash
# Level 1: Undo uncommitted changes (SAFE)
git checkout -- file.txt           # Discard changes in working directory
git reset HEAD file.txt            # Unstage file (keep changes)

# Level 2: Amend last commit (LOCAL ONLY)
git commit --amend -m "New message"
git commit --amend --no-edit       # Add missed files to last commit

# Level 3: Reset to previous commit (DANGEROUS)
git reset --soft HEAD~1           # Undo commit, keep changes staged
git reset --mixed HEAD~1          # Undo commit, keep changes unstaged (default)
git reset --hard HEAD~1           # COMPLETELY DELETE COMMIT AND CHANGES

# Level 4: Revert (SAFE for shared branches)
git revert HEAD                    # Create new commit undoing last commit
git revert abc123                  # Revert specific commit
```

#### Git Hooks for Automation
**Enterprise Use:** Pre-commit hooks for linting, pre-push hooks for tests.

```bash
# Example pre-commit hook (.git/hooks/pre-commit)
#!/bin/bash
# Run linter before allowing commit
npm run lint
if [ $? -ne 0 ]; then
    echo "Linting failed. Commit aborted."
    exit 1
fi

# Make hook executable
chmod +x .git/hooks/pre-commit
```

### Git in CI/CD Pipelines
**Industrial Integration:** Git triggers automated build, test, and deployment pipelines.

```yaml
# Sample GitHub Actions workflow (.github/workflows/deploy.yml)
name: Production Deployment
on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2  # Git checkout happens here
    - name: Run tests
      run: npm test
      
  deploy:
    needs: test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
    - uses: actions/checkout@v2
    - name: Deploy to production
      run: ./deploy.sh
```

### Common Professional Scenarios & Solutions

#### Scenario 1: Accidental Commit to Wrong Branch
```bash
# Save the commit
git stash
# Switch to correct branch
git checkout correct-branch
# Apply the changes
git stash pop
git add .
git commit -m "Fix: correct implementation"
```

#### Scenario 2: Lost Commit (Finding History)
```bash
# View reflog (history of all HEAD movements)
git reflog
# Output shows: abc1234 HEAD@{0}: commit: Message
# Recover with: git checkout abc1234
```

#### Scenario 3: Large File Accidentally Committed
```bash
# Remove from history with BFG Repo-Cleaner or git-filter-repo
git filter-repo --path large-file.zip --invert-paths
# Force push (WARNING: rewrites history for all collaborators)
git push origin --force --all
```

### Enterprise Best Practices Checklist

#### Team Collaboration Rules
1. **Branch Naming Convention:**
   - `feature/` - New features
   - `bugfix/` - Bug fixes
   - `hotfix/` - Production emergency fixes
   - `release/` - Release preparation

2. **Commit Message Standards:**
   ```
   type(scope): description
   
   [Body: What and why]
   
   [Footer: References]
   ```
   Types: feat, fix, docs, style, refactor, test, chore

3. **Pull Request Guidelines:**
   - One feature/bug per PR
   - Include tests
   - Update documentation
   - Pass all CI checks
   - Minimum 1 reviewer approval

#### Security Protocols
1. **Never commit:**
   - API keys, secrets, passwords
   - Configuration files with sensitive data
   - `.env` files
   - Private certificates

2. **Use:**
   - Environment variables
   - Secret management systems (Vault, AWS Secrets Manager)
   - `.gitignore` diligently
   - Pre-commit hooks to scan for secrets

#### .gitignore for Backend Projects
```gitignore
# Dependencies
node_modules/
vendor/
*.pyc

# Environment variables
.env
.env.local
.env.*.local

# Logs
*.log
logs/

# Runtime data
*.pid
*.seed

# IDE files
.vscode/
.idea/
*.swp
*.swo

# OS files
.DS_Store
Thumbs.db

# Build outputs
dist/
build/
*.exe
*.dll
```

### Performance Optimization
```bash
# Shallow clone for large repos (CI/CD environments)
git clone --depth 1 https://github.com/large-repo.git

# Partial clone (Git 2.19+)
git clone --filter=blob:none https://github.com/large-repo.git

# Clean up repository
git gc --aggressive  # Garbage collection
git prune            # Remove unreachable objects
```

**Final Industrial Note:** Git proficiency is measured by how well you handle mistakes and complex merges, not by basic commands. Practice conflict resolution regularly. In production teams, communication about branch status and merge intentions is as important as the technical Git skills.
```